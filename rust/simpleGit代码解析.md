# 🦀 Rust 基础语法与 Git 对象存储笔记

## 1. 字符串：`&str` vs `String`
*   **`&str` (字符串切片)**：
    *   **本质**：指向现有数据的“只读引用”。
    *   **场景**：作为函数参数（如 `content: &str`），更高效，能兼容多种输入。
*   **`String` (拥有所有权的字符串)**：
    *   **本质**：存储在堆上的可变数据。
    *   **创建**：`String::from("hello")` 或 `"hello".to_string()`。
    *   **场景**：作为返回值或结构体字段，需要独立拥有和修改数据。

## 2. 枚举 (Enum) 与变体定义
*   **元组式变体**：`Blob(String)` 
    *   `Blob` 是变体名（标签），`(String)` 是它携带的数据类型。
    *   **注意**：这里不能写成 `Blob: String`，因为枚举变体是构造函数而非普通字段。
*   **同名包装模式**：`Commit(Commit)`
    *   左边的 `Commit` 是**枚举的分支名**。
    *   右边的 `Commit` 是**具体的结构体类型**。
    *   **意义**：逻辑清晰，将相关数据结构包装进统一的枚举中。

## 3. 函数与方法 (`impl` 块)
*   **`self` (小写)**：指代当前的**实例对象**（类似 Python 的 `self`）。
    *   `&self`：只读借用，不消耗对象。
    *   `self`：夺取所有权，函数运行完对象即销毁。
*   **`Self` (大写)**：指代**当前的类型**（即 `GitObject` 的别名），常用于返回值。
*   **关联函数 vs 方法**：
    *   `fn save(&self)`：**方法**，通过 `obj.save()` 调用。
    *   `fn load(hash: &str)`：**关联函数**，通过 `GitObject::load()` 调用。

## 4. 错误处理与泛型
*   **`Result<T>`**：
    *   一个泛型“盒子”。成功时返回 `Ok(T)`，失败时返回 `Err(E)`。
    *   `anyhow::Result<String>`：简化版，只需指定成功时的类型 `String`。
*   **`?` 操作符**：
    *   **功能**：快速传播错误。如果结果是 `Err`，立刻提前返回并把错误抛给调用者；如果是 `Ok`，则取出里面的值继续执行。
*   **返回值语法**：使用 `-> Type`。末尾不加分号的表达式即为返回值（隐式返回）。

## 5. Git 存储逻辑 (Content-Addressable)
*   **序列化**：`serde_json::to_string(self)` 将对象转为 JSON 文本。
*   **哈希计算**：`hash_content` 生成唯一的“身份证号”。
*   **路径设计**：
    *   `prefix = &hash[..2]`：取哈希前 2 位做文件夹名。
    *   `suffix = &hash[2..]`：取剩余位做文件名。
    *   **目的**：解决单文件夹下文件过多导致的系统性能瓶颈（分散压力）。
*   **SHA-1 警告**：
    *   SHA-1 在密码学上已被破解（易受碰撞攻击）。
    *   **原则**：学习和兼容旧系统可用，安全敏感的新系统应换用 **SHA-256**。

## 6. 常用库速查
*   `serde`：Rust 序列化/反序列化的事实标准。
*   `anyhow`：极其方便的错误处理库。
*   `hex`：负责二进制数据与十六进制字符串的相互转换。
*   `std::fs` & `std::path`：标准库提供的文件系统操作和跨平台路径处理。

---

**学习建议**：
初学 Rust 时，优先掌握 **所有权(Ownership)** 和 **模式匹配(Match)**。当你看到 `&`、`mut`、`?` 时，多想想内存是谁的、数据能不能改、报错了谁来处理。